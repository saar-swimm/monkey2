import logging
from dataclasses import dataclass
from enum import Enum
from itertools import product
from typing import List, Tuple, Union

logger = logging.getLogger(__name__)


class SecretType(Enum):
    CACHED = 1
    PASSWORD = 2
    LM_HASH = 3
    NT_HASH = 4


@dataclass
class Credentials:
    username: Union[str, None]
    secret: Union[str, None]
    secret_type: SecretType


def get_credentials(
    usernames: List[str],
    passwords: List[str],
    lm_hashes: List[str],
    nt_hashes: List[str],
    is_windows: bool,
) -> List[Credentials]:
    username_domain_combinations = _get_username_domain_combinations(usernames, is_windows)

    credentials = []
    credentials.extend(_get_empty_credentials(is_windows))
    credentials.extend(_get_username_only_credentials(username_domain_combinations, is_windows))
    credentials.extend(_get_username_password_credentials(username_domain_combinations, passwords))
    credentials.extend(_get_username_lm_hash_credentials(username_domain_combinations, lm_hashes))
    credentials.extend(_get_username_nt_hash_credentials(username_domain_combinations, nt_hashes))

    return credentials


def _get_username_domain_combinations(usernames: List[str], is_windows) -> List[str]:
    username_domain_combinations = set(usernames)
    for u in usernames:
        username_domain_combinations.add(f".\\{u}")

    if is_windows:
        try:
            domain, current_username = _get_current_user_and_domain()
            username_domain_combinations.add(current_username)
            username_domain_combinations.add(f"{domain}\\{current_username}")
            username_domain_combinations.add(f".\\{current_username}")
            for u in usernames:
                username_domain_combinations.add(f"{domain}\\{u}")
        except Exception as ex:
            logger.error(f"Failed to get the current user's username and domain name: {ex}")

    return list(username_domain_combinations)


def _get_current_user_and_domain() -> Tuple[str, str]:
    import win32api

    return win32api.GetUserNameEx(win32api.NameSamCompatible).split("\\")


# On Windows systems, when username == None and password == None, the current user's credentials
# will be used to attempt to log into the victim only on the first hop, from island
# to a machine. Propagating after the first hop is not possible at the moment.
# See this: https://security.stackexchange.com/questions/120422/powershell-and-cached-credentials
def _get_empty_credentials(is_windows: bool) -> List[Credentials]:
    if is_windows:
        return [Credentials(username=None, secret=None, secret_type=SecretType.CACHED)]

    return []


# On Windows systems, when password == None, the current user's password will be used to attempt to
# log into the victim.
def _get_username_only_credentials(usernames: List[str], is_windows: bool) -> List[Credentials]:
    credentials = [
        Credentials(username=username, secret="", secret_type=SecretType.PASSWORD)
        for username in usernames
    ]

    if is_windows:
        credentials.extend(
            [
                Credentials(username=username, secret=None, secret_type=SecretType.CACHED)
                for username in usernames
            ]
        )

    return credentials


def _get_username_password_credentials(
    usernames: List[str], passwords: List[str]
) -> List[Credentials]:
    return _get_username_secret_credentials(usernames, passwords, SecretType.PASSWORD)


def _get_username_lm_hash_credentials(
    usernames: List[str], lm_hashes: List[str]
) -> List[Credentials]:
    return _get_username_secret_credentials(usernames, lm_hashes, SecretType.LM_HASH)


def _get_username_nt_hash_credentials(
    usernames: List[str], nt_hashes: List[str]
) -> List[Credentials]:
    return _get_username_secret_credentials(usernames, nt_hashes, SecretType.NT_HASH)


def _get_username_secret_credentials(
    usernames: List[str], secrets: List[str], secret_type: SecretType
) -> List[Credentials]:
    username_secret_pairs = product(usernames, secrets)

    return [
        Credentials(credentials[0], credentials[1], secret_type)
        for credentials in username_secret_pairs
    ]
